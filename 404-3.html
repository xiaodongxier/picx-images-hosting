<!doctype html>
<html lang="zh-CN">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>请稍等，图片正在加载</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <link href="https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css" rel="stylesheet">

  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            primary: '#6366F1', // 靛蓝色
            secondary: '#10B981', // 绿色
            accent: '#F472B6', // 粉色
            dark: '#0F172A',
            light: '#F8FAFC'
          },
          fontFamily: {
            inter: ['Inter', 'system-ui', 'sans-serif'],
          },
        },
      }
    }
  </script>

  <style type="text/tailwindcss">
    @layer utilities {
      .text-shadow-glow {
        text-shadow: 0 0 10px currentColor, 0 0 20px currentColor, 0 0 30px currentColor;
      }
      .text-gradient {
        background-clip: text;
        -webkit-background-clip: text;
        color: transparent;
      }
      .animate-float {
        animation: float 6s ease-in-out infinite;
      }
      .animate-float-delay-1 {
        animation: float 6s ease-in-out 1s infinite;
      }
      .animate-float-delay-2 {
        animation: float 6s ease-in-out 2s infinite;
      }
      .animate-pulse-slow {
        animation: pulse 4s cubic-bezier(0.4, 0, 0.6, 1) infinite;
      }
      .backdrop-blur {
        backdrop-filter: blur(8px);
      }
      .grid-pattern {
        background-size: 40px 40px;
        background-image: 
          linear-gradient(to right, rgba(99, 102, 241, 0.05) 1px, transparent 1px),
          linear-gradient(to bottom, rgba(99, 102, 241, 0.05) 1px, transparent 1px);
      }
    }
    
    @keyframes float {
      0% { transform: translateY(0px); }
      50% { transform: translateY(-20px); }
      100% { transform: translateY(0px); }
    }
  </style>
</head>

<body
  class="m-0 bg-gradient-to-br from-dark via-slate-900 to-slate-800 text-light font-inter min-h-screen flex flex-col items-center justify-center overflow-hidden relative grid-pattern">
  <!-- 背景装饰元素 -->
  <div class="absolute inset-0 overflow-hidden pointer-events-none">
    <div class="absolute top-1/4 -left-20 w-96 h-96 bg-primary/20 rounded-full blur-3xl animate-pulse-slow"></div>
    <div class="absolute bottom-1/3 -right-20 w-96 h-96 bg-accent/20 rounded-full blur-3xl animate-pulse-slow"
      style="animation-delay: 2s;"></div>
    <div
      class="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-[800px] h-[800px] bg-secondary/10 rounded-full blur-3xl animate-pulse-slow"
      style="animation-delay: 1s;"></div>
  </div>

  <!-- 浮动装饰元素 -->
  <div class="absolute top-[10%] left-[10%] w-16 h-16 rounded-full bg-primary/10 backdrop-blur animate-float"></div>
  <div
    class="absolute bottom-[15%] right-[15%] w-24 h-24 rounded-full bg-accent/10 backdrop-blur animate-float-delay-1">
  </div>
  <div class="absolute top-[70%] left-[20%] w-20 h-20 rounded-full bg-secondary/10 backdrop-blur animate-float-delay-2">
  </div>

  <!-- 主内容 -->
  <div class="relative z-10 text-center px-4 max-w-3xl w-full">
    <div
      class="inline-block mb-8 p-6 rounded-full bg-white/10 backdrop-blur border border-white/20 animate-float shadow-lg shadow-primary/20">
      <i class="fa fa-picture-o text-6xl text-gradient bg-gradient-to-r from-primary via-accent to-secondary"></i>
    </div>

    <h1
      class="text-[clamp(1.8rem,5vw,3rem)] font-bold mb-6 tracking-tight text-gradient bg-gradient-to-r from-primary via-accent to-secondary transition-all duration-1000 relative">
      图片还在路上
      <span class="inline-block animate-bounce ml-2">🚚💨</span>
      <span
        class="absolute inset-0 bg-gradient-to-r from-primary/20 via-transparent to-secondary/20 blur-sm opacity-30"></span>
    </h1>

    <div id="timer"
      class="text-[clamp(3rem,10vw,6rem)] font-extrabold mb-6 text-primary text-shadow-glow transition-all duration-500 transform hover:scale-110 hover:text-accent">
      60</div>

    <div id="msg"
      class="text-[clamp(1rem,3vw,1.25rem)] text-slate-300 mb-10 min-h-[2rem] transition-all duration-700 ease-in-out px-4 py-2 rounded-lg bg-white/5 backdrop-blur">
      别急，一切正在准备中…
    </div>

    <!-- 粒子动画画布 -->
    <canvas id="particles"
      class="w-full h-72 rounded-2xl bg-white/5 backdrop-blur border border-white/10 shadow-xl shadow-primary/10 mb-8"></canvas>

    <div id="musicTip"
      class="text-sm text-slate-400 flex items-center justify-center gap-2 group cursor-pointer hover:text-primary transition-colors duration-300">
      <i class="fa fa-music animate-pulse"></i>
      <span>点击页面启动背景音乐，让等待更轻松</span>
    </div>
  </div>

  <!-- 装饰性进度条 -->
  <div class="absolute bottom-0 left-0 right-0 h-2 bg-white/10 overflow-hidden">
    <div id="progressBar"
      class="h-full bg-gradient-to-r from-primary via-accent to-secondary w-0 transition-all duration-1000"></div>
  </div>

  <!-- 新的背景音乐 - 更有节奏感的电子音乐 -->
  <audio id="bgm" src="https://www.soundhelix.com/examples/mp3/SoundHelix-Song-3.mp3" loop preload="auto"></audio>

  <script>
    // 倒计时功能
    let sec = 60;
    const timerEl = document.getElementById('timer');
    const msgEl = document.getElementById('msg');
    const progressBar = document.getElementById('progressBar');
    const bgm = document.getElementById('bgm');
    const messages = [
      "⌛ 网络正在帮你打包快递…",
      "🐢 有点慢，但乌龟也能到终点！",
      "🎵 等待的时候，不妨哼一首歌～",
      "🤖 服务器正在努力唤醒图片…",
      "🌌 放松一下眼睛，眺望一下远方吧。",
      "☕ 就像一杯好咖啡，值得等待",
      "🔧 工程师正在调试最后一个像素",
      "🚀 图片正在穿越网络隧道",
      "📡 信号已接收，正在解码中",
      "✨ 为你准备了一份视觉盛宴",
      "🌈 加载进度: " + Math.round(((60 - sec) / 60) * 100) + "%",
      "🚦 数据传输中，请稍候..."
    ];

    // 更新进度条和进度消息
    function updateProgress() {
      const progress = ((60 - sec) / 60) * 100;
      progressBar.style.width = `${progress}%`;

      // 更新进度消息
      messages[10] = "🌈 加载进度: " + Math.round(progress) + "%";
    }

    // 倒计时逻辑
    function tick() {
      // 添加数字变化动画
      timerEl.classList.add('scale-110', 'opacity-70');
      setTimeout(() => {
        timerEl.classList.remove('scale-110', 'opacity-70');
      }, 300);

      timerEl.textContent = sec;
      updateProgress();

      // 随机更换提示信息
      if (sec % 4 === 0) {
        msgEl.style.opacity = '0';
        msgEl.style.transform = 'translateY(10px)';
        setTimeout(() => {
          msgEl.textContent = messages[Math.floor(Math.random() * messages.length)];
          msgEl.style.opacity = '1';
          msgEl.style.transform = 'translateY(0)';
        }, 300);
      }

      if (sec > 0) {
        sec--;
        setTimeout(tick, 1000);
      } else {
        msgEl.textContent = "✅ 图片准备就绪，正在刷新…";
        // 完成动画
        timerEl.classList.add('text-secondary');
        // 创建庆祝粒子爆炸
        createExplosion(canvas.width / 2, canvas.height / 2, 100);

        setTimeout(() => {
          // 添加页面过渡效果
          document.body.classList.add('opacity-0', 'transition-opacity', 'duration-1000');
          setTimeout(() => location.reload(), 1000);
        }, 2000);
      }
    }
    tick();

    // 粒子网络动画 - 增强版
    const canvas = document.getElementById('particles');
    const ctx = canvas.getContext('2d');

    // 设置Canvas尺寸为响应式
    function resizeCanvas() {
      const container = canvas.parentElement;
      canvas.width = container.clientWidth;
      canvas.height = canvas.clientHeight;
    }

    // 初始化尺寸并监听窗口变化
    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);

    // 粒子类
    class Particle {
      constructor() {
        this.x = Math.random() * canvas.width;
        this.y = Math.random() * canvas.height;
        this.size = Math.random() * 3 + 1;
        this.speedX = Math.random() * 0.8 - 0.4;
        this.speedY = Math.random() * 0.8 - 0.4;
        this.color = this.getRandomColor();
        this.alpha = Math.random() * 0.8 + 0.2;
        this.pulse = Math.random() * Math.PI * 2; // 用于呼吸效果
      }

      getRandomColor() {
        const colors = [
          'rgba(99, 102, 241, 0.8)', // primary
          'rgba(16, 185, 129, 0.8)', // secondary
          'rgba(244, 114, 182, 0.8)'  // accent
        ];
        return colors[Math.floor(Math.random() * colors.length)];
      }

      update() {
        // 移动粒子
        this.x += this.speedX;
        this.y += this.speedY;

        // 呼吸效果
        this.pulse += 0.02;
        const pulseSize = Math.sin(this.pulse) * 0.5 + 1; // 1到1.5倍大小变化
        this.currentSize = this.size * pulseSize;

        // 边界检查 - 从另一边出现
        if (this.x < 0) this.x = canvas.width;
        if (this.x > canvas.width) this.x = 0;
        if (this.y < 0) this.y = canvas.height;
        if (this.y > canvas.height) this.y = 0;
      }

      draw() {
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.currentSize, 0, Math.PI * 2);
        ctx.fill();

        // 粒子光晕效果
        ctx.fillStyle = this.color.replace('0.8', '0.2');
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.currentSize * 2, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    // 爆炸粒子类
    class ExplosionParticle {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.size = Math.random() * 4 + 1;
        this.speedX = Math.random() * 6 - 3;
        this.speedY = Math.random() * 6 - 3;
        this.color = ['#6366F1', '#10B981', '#F472B6'][Math.floor(Math.random() * 3)];
        this.alpha = 1;
        this.life = Math.random() * 30 + 20; // 生命周期
      }

      update() {
        this.x += this.speedX;
        this.y += this.speedY;
        this.life--;
        this.alpha = this.life / 50;
        this.size *= 0.97; // 逐渐缩小
      }

      draw() {
        ctx.save();
        ctx.globalAlpha = this.alpha;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();

        // 尾迹效果
        ctx.fillStyle = this.color + '40'; // 透明度40%
        ctx.beginPath();
        ctx.arc(this.x - this.speedX * 2, this.y - this.speedY * 2, this.size * 0.7, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
    }

    // 创建粒子数组
    let particles = [];
    const particleCount = 80;
    let explosionParticles = [];

    function initParticles() {
      particles = [];
      for (let i = 0; i < particleCount; i++) {
        particles.push(new Particle());
      }
    }

    // 创建爆炸效果
    function createExplosion(x, y, count) {
      for (let i = 0; i < count; i++) {
        explosionParticles.push(new ExplosionParticle(x, y));
      }
    }

    // 连接粒子的线 - 增强版
    function connectParticles() {
      for (let a = 0; a < particles.length; a++) {
        for (let b = a; b < particles.length; b++) {
          const dx = particles[a].x - particles[b].x;
          const dy = particles[a].y - particles[b].y;
          const distance = Math.sqrt(dx * dx + dy * dy);

          // 距离小于120时绘制连接线，线的粗细随距离变化
          if (distance < 120) {
            const opacity = 1 - distance / 120;
            const lineWidth = 0.8 * opacity;

            // 动态颜色
            const gradient = ctx.createLinearGradient(particles[a].x, particles[a].y, particles[b].x, particles[b].y);
            gradient.addColorStop(0, particles[a].color);
            gradient.addColorStop(1, particles[b].color);

            ctx.strokeStyle = gradient;
            ctx.lineWidth = lineWidth;
            ctx.beginPath();
            ctx.moveTo(particles[a].x, particles[a].y);
            ctx.lineTo(particles[b].x, particles[b].y);
            ctx.stroke();
          }
        }
      }
    }

    // 鼠标交互增强
    let mouse = {
      x: null,
      y: null,
      radius: 120,
      isDown: false
    };

    window.addEventListener('mousemove', (e) => {
      const rect = canvas.getBoundingClientRect();
      mouse.x = e.x - rect.left;
      mouse.y = e.y - rect.top;

      // 鼠标移动时创建轨迹粒子
      if (mouse.isDown) {
        createExplosion(mouse.x, mouse.y, 3);
      }
    });

    // 鼠标按下效果
    window.addEventListener('mousedown', () => {
      mouse.isDown = true;
    });

    window.addEventListener('mouseup', () => {
      mouse.isDown = false;
    });

    // 鼠标离开Canvas区域
    window.addEventListener('mouseout', () => {
      mouse.x = null;
      mouse.y = null;
      mouse.isDown = false;
    });

    // 触摸设备支持
    canvas.addEventListener('touchmove', (e) => {
      e.preventDefault();
      const rect = canvas.getBoundingClientRect();
      const touch = e.touches[0];
      mouse.x = touch.clientX - rect.left;
      mouse.y = touch.clientY - rect.top;
      createExplosion(mouse.x, mouse.y, 3);
    }, { passive: false });

    // 鼠标与粒子交互增强
    function interactWithParticles() {
      if (!mouse.x || !mouse.y) return;

      for (let i = 0; i < particles.length; i++) {
        const dx = mouse.x - particles[i].x;
        const dy = mouse.y - particles[i].y;
        const distance = Math.sqrt(dx * dx + dy * dy);

        // 鼠标靠近粒子时产生排斥力，鼠标按下时吸引力
        if (distance < mouse.radius) {
          const force = (mouse.radius - distance) / mouse.radius;
          const angle = Math.atan2(dy, dx);
          const forceMultiplier = mouse.isDown ? -0.5 : 1; // 按下时反向力
          const forceX = Math.cos(angle) * force * forceMultiplier;
          const forceY = Math.sin(angle) * force * forceMultiplier;

          particles[i].x += forceX;
          particles[i].y += forceY;

          // 鼠标附近粒子发光效果
          if (distance < mouse.radius * 0.5) {
            particles[i].size = Math.max(particles[i].size, 4);
          }
        }
      }
    }

    // 动画循环
    function animateParticles() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // 绘制网格背景
      drawGrid();

      // 更新和绘制普通粒子
      for (let i = 0; i < particles.length; i++) {
        particles[i].update();
        particles[i].draw();
      }

      // 更新和绘制爆炸粒子
      for (let i = 0; i < explosionParticles.length; i++) {
        explosionParticles[i].update();
        explosionParticles[i].draw();

        // 移除生命周期结束的粒子
        if (explosionParticles[i].life <= 0) {
          explosionParticles.splice(i, 1);
          i--;
        }
      }

      connectParticles();
      interactWithParticles();

      // 随机创建小爆炸效果增加活力
      if (Math.random() < 0.05) {
        createExplosion(
          Math.random() * canvas.width,
          Math.random() * canvas.height,
          Math.floor(Math.random() * 10) + 5
        );
      }

      requestAnimationFrame(animateParticles);
    }

    // 绘制动态网格
    function drawGrid() {
      const gridSize = 30;
      const time = Date.now() * 0.001;

      ctx.strokeStyle = 'rgba(99, 102, 241, 0.1)';
      ctx.lineWidth = 1;

      // 水平网格线，随时间移动
      for (let y = 0; y < canvas.height; y += gridSize) {
        const offset = Math.sin(time + y * 0.01) * 10;
        ctx.beginPath();
        ctx.moveTo(0 + offset, y);
        ctx.lineTo(canvas.width + offset, y);
        ctx.stroke();
      }

      // 垂直网格线，随时间移动
      for (let x = 0; x < canvas.width; x += gridSize) {
        const offset = Math.cos(time + x * 0.01) * 10;
        ctx.beginPath();
        ctx.moveTo(x, 0 + offset);
        ctx.lineTo(x, canvas.height + offset);
        ctx.stroke();
      }
    }

    // 初始化并启动粒子动画
    initParticles();
    animateParticles();

    // 音乐播放功能
    function playMusic() {
      bgm.play().then(() => {
        document.getElementById('musicTip').innerHTML = '<i class="fa fa-music text-secondary"></i><span>正在播放背景音乐...</span>';
      }).catch(() => {
        // 播放失败时不做处理
      });
      document.removeEventListener('click', playMusic);
      document.getElementById('musicTip').removeEventListener('click', playMusic);
    }

    // 尝试自动播放音乐
    playMusic();

    // 点击页面任意位置播放音乐
    document.addEventListener('click', playMusic);
    document.getElementById('musicTip').addEventListener('click', playMusic);

    // 增强版点击波纹效果
    document.addEventListener('click', (e) => {
      // 创建外层波纹
      const ripple = document.createElement('div');
      ripple.className = 'fixed rounded-full bg-primary/20 transform -translate-x-1/2 -translate-y-1/2 pointer-events-none';
      ripple.style.left = `${e.clientX}px`;
      ripple.style.top = `${e.clientY}px`;
      ripple.style.width = '0';
      ripple.style.height = '0';
      ripple.style.animation = 'ripple 1.5s ease-out forwards';
      document.body.appendChild(ripple);

      // 创建内层波纹
      const innerRipple = document.createElement('div');
      innerRipple.className = 'fixed rounded-full bg-accent/30 transform -translate-x-1/2 -translate-y-1/2 pointer-events-none';
      innerRipple.style.left = `${e.clientX}px`;
      innerRipple.style.top = `${e.clientY}px`;
      innerRipple.style.width = '0';
      innerRipple.style.height = '0';
      innerRipple.style.animation = 'ripple 1s ease-out 0.2s forwards';
      document.body.appendChild(innerRipple);

      // 移除波纹元素
      setTimeout(() => {
        ripple.remove();
        innerRipple.remove();
      }, 1700);
    });

    // 添加波纹动画样式
    const style = document.createElement('style');
    style.textContent = `
      @keyframes ripple {
        0% { width: 0; height: 0; opacity: 1; }
        100% { width: 300px; height: 300px; opacity: 0; }
      }
    `;
    document.head.appendChild(style);
  </script>
</body>

</html>